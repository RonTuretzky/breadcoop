<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BreadchainCoop Activity Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas {
            display: block;
        }

        #header {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        #header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }

        #header .subtitle {
            font-size: 12px;
            color: #888;
        }

        #header .org-link {
            font-size: 11px;
            color: #6366f1;
            text-decoration: none;
            margin-top: 4px;
            display: inline-block;
        }

        #header .org-link:hover {
            text-decoration: underline;
        }

        #status-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-width: 180px;
        }

        #status-panel h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .status-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .status-pass { background: #22c55e; box-shadow: 0 0 10px #22c55e; }
        .status-fail { background: #ef4444; box-shadow: 0 0 10px #ef4444; }
        .status-pending { background: #eab308; }
        .status-unknown { background: #666; }

        /* Legend Panel */
        #legend-panel {
            position: absolute;
            bottom: 120px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 15px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        #legend-panel h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 8px;
        }

        .legend-section {
            margin-bottom: 12px;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-section h4 {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .pr-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            flex-shrink: 0;
        }

        .pr-pass { background: rgba(34, 197, 94, 0.9); }
        .pr-fail { background: rgba(239, 68, 68, 0.9); }
        .pr-pending { background: rgba(234, 179, 8, 0.9); }
        .pr-none { background: rgba(80, 80, 220, 0.9); }

        #footer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #footer .tracking-info {
            font-size: 13px;
            color: #aaa;
        }

        #footer .update-time {
            font-size: 13px;
            color: #888;
        }

        #tooltip {
            position: absolute;
            background: rgba(20, 20, 30, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            pointer-events: none;
            display: none;
            z-index: 1000;
            max-width: 350px;
            backdrop-filter: blur(10px);
        }

        #tooltip .tooltip-title {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
            margin-bottom: 6px;
        }

        #tooltip .tooltip-repo {
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
        }

        #tooltip .tooltip-author {
            font-size: 12px;
            color: #6366f1;
            margin-bottom: 4px;
        }

        #tooltip .tooltip-time {
            font-size: 12px;
            color: #aaa;
        }

        #tooltip .tooltip-labels {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }

        #tooltip .label-tag {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(99, 102, 241, 0.3);
            color: #a5b4fc;
        }

        /* Hide Menu */
        #hide-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(15, 15, 25, 0.95);
            padding: 25px 30px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            display: none;
            min-width: 400px;
            max-height: 70vh;
            overflow-y: auto;
        }

        #hide-menu h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #fff;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        #hide-menu .menu-section {
            margin-bottom: 20px;
        }

        #hide-menu .menu-section h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 10px;
        }

        #hide-menu .menu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #hide-menu .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        #hide-menu .menu-item.hidden {
            opacity: 0.5;
        }

        #hide-menu .menu-item .name {
            flex: 1;
            font-size: 13px;
        }

        #hide-menu .menu-item .status-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
        }

        #hide-menu .menu-item .status-badge.visible {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        #hide-menu .menu-item .status-badge.hidden {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        #hide-menu .close-hint {
            text-align: center;
            font-size: 12px;
            color: #666;
            margin-top: 15px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 50;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #22c55e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .controls-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        /* Top buttons */
        .top-button {
            position: absolute;
            top: 20px;
            z-index: 100;
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .top-button:hover {
            background: rgba(30, 30, 40, 0.9);
        }

        .top-button.active {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
        }

        .theme-toggle { right: 220px; }
        .fit-button { right: 305px; }
        .lock-button { right: 380px; }

        .lock-button.active {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }

        /* Light mode */
        body.light-mode {
            background: #f5f5f7;
            color: #1a1a1a;
        }

        body.light-mode #header,
        body.light-mode #status-panel,
        body.light-mode #legend-panel,
        body.light-mode #footer,
        body.light-mode .top-button,
        body.light-mode #hide-menu {
            background: rgba(255, 255, 255, 0.9);
            border-color: rgba(0, 0, 0, 0.1);
        }

        body.light-mode #header h1,
        body.light-mode #hide-menu h2 {
            color: #1a1a1a;
        }

        body.light-mode #header .subtitle,
        body.light-mode #status-panel h3,
        body.light-mode #legend-panel h3,
        body.light-mode .legend-section h4,
        body.light-mode #hide-menu .menu-section h4 {
            color: #666;
        }

        body.light-mode .status-item,
        body.light-mode .legend-item,
        body.light-mode #hide-menu .menu-item .name {
            color: #333;
        }

        body.light-mode #footer .tracking-info {
            color: #555;
        }

        body.light-mode #footer .update-time,
        body.light-mode .controls-hint {
            color: #777;
        }

        body.light-mode .top-button {
            color: #333;
        }

        body.light-mode #tooltip {
            background: rgba(255, 255, 255, 0.95);
            border-color: rgba(0, 0, 0, 0.15);
        }

        body.light-mode #tooltip .tooltip-title {
            color: #1a1a1a;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>

        <div id="header">
            <h1 id="org-title">ORGANIZATION ACTIVITY TRACKER</h1>
            <div class="subtitle">3D Visualization - Open PRs by Repository</div>
            <a href="#" id="org-link" class="org-link" target="_blank">View on GitHub</a>
        </div>

        <button class="top-button lock-button" id="lock-button" onclick="toggleLock()">
            <span id="lock-icon">ðŸ”“</span>
            <span id="lock-label">Lock</span>
        </button>

        <button class="top-button fit-button" id="fit-button" onclick="fitToScreen()">
            <span>âŠ¡</span>
            <span>Fit</span>
        </button>

        <button class="top-button theme-toggle" id="theme-toggle" onclick="toggleTheme()">
            <span id="theme-icon">â˜¾</span>
            <span id="theme-label">Light</span>
        </button>

        <div id="status-panel">
            <h3>CI Status</h3>
            <div id="status-counts">
                <div class="status-item">
                    <div class="status-icon status-pass"></div>
                    <span><span id="pass-count">0</span> passing</span>
                </div>
                <div class="status-item">
                    <div class="status-icon status-fail"></div>
                    <span><span id="fail-count">0</span> failing</span>
                </div>
                <div class="status-item">
                    <div class="status-icon status-pending"></div>
                    <span><span id="pending-count">0</span> pending</span>
                </div>
            </div>
        </div>

        <div id="legend-panel">
            <h3>Legend</h3>
            <div class="legend-section">
                <h4>CI Status</h4>
                <div class="legend-item">
                    <div class="pr-badge pr-pass">#123 âœ“</div>
                    <span>Passing</span>
                </div>
                <div class="legend-item">
                    <div class="pr-badge pr-fail">#123 âœ—</div>
                    <span>Failing</span>
                </div>
                <div class="legend-item">
                    <div class="pr-badge pr-pending">#123 â‹¯</div>
                    <span>Pending</span>
                </div>
            </div>
            <div class="legend-section">
                <h4>Node Types</h4>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6366f1; width: 20px; height: 20px;"></div>
                    <span>Repository</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #22c55e; width: 14px; height: 14px;"></div>
                    <span>Pull Request</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #88aaff; width: 8px; height: 8px;"></div>
                    <span>Commit</span>
                </div>
            </div>
        </div>

        <div id="footer">
            <div class="tracking-info">
                Tracking: <span id="repo-count">0</span> repos |
                <span id="pr-count">0</span> open PRs |
                Press <kbd>`</kbd> to hide/show
            </div>
            <div class="update-time">
                Last updated: <span id="update-time">Loading...</span>
            </div>
        </div>

        <div id="tooltip">
            <div class="tooltip-title"></div>
            <div class="tooltip-repo"></div>
            <div class="tooltip-author"></div>
            <div class="tooltip-time"></div>
            <div class="tooltip-labels"></div>
        </div>

        <div id="hide-menu">
            <h2>Hide/Show Repositories</h2>
            <div id="repos-section" class="menu-section">
                <h4>Repositories</h4>
                <div id="repos-list"></div>
            </div>
            <div class="close-hint">Press <kbd>`</kbd> or <kbd>Esc</kbd> to close | <kbd>0</kbd> show all</div>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <div>Loading organization data...</div>
        </div>

        <div class="controls-hint">
            Drag to rotate | Shift+drag to pan | Scroll to zoom | Click to open PR | T theme | L lock | ` hide menu
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    // ============================================================================
    // Configuration
    // ============================================================================
    const CONFIG = {
        dataUrl: './data/org_data.json',
        staleMinutes: 60,
        colors: {
            fresh: 0x22c55e,
            recent: 0xeab308,
            aging: 0xf97316,
            stale: 0xef4444,
            pass: 0x22c55e,
            fail: 0xef4444,
            pending: 0xeab308,
            default: 0x6366f1,
        },
        scene: {
            dark: {
                background: 0x0a0a0f,
                ambientLight: 0x404040,
                directionalLight: 0xffffff,
                gridColor: 0x222233,
                lineColor: 0x666688,
            },
            light: {
                background: 0xf0f0f5,
                ambientLight: 0x808080,
                directionalLight: 0xffffff,
                gridColor: 0xccccdd,
                lineColor: 0x8888aa,
            },
        }
    };

    // State
    let isDarkMode = true;
    let isLocked = false;
    let scene, camera, renderer;
    let raycaster, mouse;
    let clickableObjects = [];
    let hoverableObjects = [];
    let currentData = null;
    let hiddenRepos = new Set();
    let hideMenuOpen = false;

    // Avatar texture cache
    const avatarTextureCache = new Map();

    // Camera controls
    let cameraAngle = 0.3;
    let cameraRadius = 80;
    let cameraHeight = 40;
    let cameraTargetX = 0;
    let cameraTargetZ = 0;
    let isDragging = false;
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // ============================================================================
    // Initialization
    // ============================================================================

    function init() {
        const themeColors = getThemeColors();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(themeColors.background);
        scene.fog = new THREE.Fog(themeColors.background, 150, 400);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        updateCameraPosition();

        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lighting
        const ambientLight = new THREE.AmbientLight(themeColors.ambientLight, 0.6);
        ambientLight.name = 'ambientLight';
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(themeColors.directionalLight, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Grid
        const gridHelper = new THREE.GridHelper(200, 50, themeColors.gridColor, themeColors.gridColor);
        gridHelper.position.y = -3;
        gridHelper.name = 'gridHelper';
        scene.add(gridHelper);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        setupEventListeners();
        loadData();
        animate();
    }

    function getThemeColors() {
        return isDarkMode ? CONFIG.scene.dark : CONFIG.scene.light;
    }

    function setupEventListeners() {
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', onKeyDown);

        const canvas = renderer.domElement;
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('mouseleave', onMouseUp);
        canvas.addEventListener('wheel', onMouseWheel, { passive: false });
        canvas.addEventListener('click', onClick);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
        if (event.key === '`' || event.key === 'Escape') {
            toggleHideMenu();
        } else if (event.key === '0' && hideMenuOpen) {
            showAllRepos();
        } else if (event.key === 't' || event.key === 'T') {
            toggleTheme();
        } else if (event.key === 'l' || event.key === 'L') {
            toggleLock();
        } else if (event.key === 'f' || event.key === 'F') {
            fitToScreen();
        }
    }

    // ============================================================================
    // Data Loading
    // ============================================================================

    async function loadData() {
        try {
            const response = await fetch(CONFIG.dataUrl);
            if (!response.ok) throw new Error(`Failed to load data: ${response.status}`);
            currentData = await response.json();
            document.getElementById('loading').style.display = 'none';
            updateStats();
            buildScene();
            buildHideMenu();
            fitToScreen();
        } catch (error) {
            console.error('Error loading data:', error);
            document.getElementById('loading').innerHTML = `
                <div style="color: #ef4444;">Error loading data</div>
                <div style="font-size: 12px; margin-top: 10px;">${error.message}</div>
                <div style="font-size: 11px; margin-top: 10px; color: #888;">
                    Run <code>python fetch_org_data.py</code> to generate data
                </div>
            `;
        }
    }

    function updateStats() {
        if (!currentData) return;

        const org = currentData.organization || 'Unknown';
        document.getElementById('org-title').textContent = `${org.toUpperCase()} ACTIVITY TRACKER`;
        document.getElementById('org-link').href = `https://github.com/${org}`;
        document.getElementById('org-link').textContent = `github.com/${org}`;

        document.getElementById('repo-count').textContent = currentData.stats?.repos_with_prs || 0;
        document.getElementById('pr-count').textContent = currentData.stats?.total_open_prs || 0;

        if (currentData.generated_at) {
            const date = new Date(currentData.generated_at);
            document.getElementById('update-time').textContent = date.toLocaleString();
        }

        let passCount = 0, failCount = 0, pendingCount = 0;
        if (currentData.trees) {
            for (const tree of Object.values(currentData.trees)) {
                countCIStatus(tree, (status) => {
                    if (status === 'pass') passCount++;
                    else if (status === 'fail') failCount++;
                    else if (status === 'pending') pendingCount++;
                });
            }
        }
        document.getElementById('pass-count').textContent = passCount;
        document.getElementById('fail-count').textContent = failCount;
        document.getElementById('pending-count').textContent = pendingCount;
    }

    function countCIStatus(node, callback) {
        if (node.ci_status) callback(node.ci_status);
        if (node.children) {
            for (const child of node.children) countCIStatus(child, callback);
        }
    }

    // ============================================================================
    // Avatar Sprites
    // ============================================================================

    function createCircularPlaceholder() {
        const canvas = document.createElement('canvas');
        const size = 64;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Draw circular background
        ctx.beginPath();
        ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
        ctx.fillStyle = isDarkMode ? '#4488ff' : '#5577dd';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        return canvas;
    }

    function createCircularAvatarTexture(img) {
        const canvas = document.createElement('canvas');
        const size = 64;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // Create circular clipping path
        ctx.beginPath();
        ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // Draw the image centered and scaled to fill
        ctx.drawImage(img, 0, 0, size, size);

        // Draw border
        ctx.beginPath();
        ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    function createAvatarSprite(avatarUrl) {
        // Create placeholder circular texture first
        const placeholderCanvas = createCircularPlaceholder();
        const placeholderTexture = new THREE.CanvasTexture(placeholderCanvas);

        const material = new THREE.SpriteMaterial({
            map: placeholderTexture,
            transparent: true,
        });
        const sprite = new THREE.Sprite(material);

        // Load the actual avatar image
        if (avatarUrl && !avatarTextureCache.has(avatarUrl)) {
            avatarTextureCache.set(avatarUrl, 'loading');

            // Load image with size parameter for smaller download
            const sizedUrl = avatarUrl.includes('?') ? `${avatarUrl}&s=64` : `${avatarUrl}?s=64`;

            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function() {
                const texture = createCircularAvatarTexture(img);
                avatarTextureCache.set(avatarUrl, texture);

                // Update the material with the circular texture
                material.map = texture;
                material.needsUpdate = true;
            };
            img.onerror = function() {
                avatarTextureCache.set(avatarUrl, 'error');
            };
            img.src = sizedUrl;
        } else if (avatarUrl && avatarTextureCache.get(avatarUrl) !== 'loading' && avatarTextureCache.get(avatarUrl) !== 'error') {
            // Use cached texture
            material.map = avatarTextureCache.get(avatarUrl);
            material.needsUpdate = true;
        }

        return sprite;
    }

    // ============================================================================
    // Scene Building
    // ============================================================================

    function buildScene() {
        // Clear existing data objects
        const toRemove = [];
        scene.traverse((obj) => {
            if (obj.userData?.isDataObject) toRemove.push(obj);
        });
        toRemove.forEach(obj => {
            scene.remove(obj);
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                else obj.material.dispose();
            }
        });

        clickableObjects = [];
        hoverableObjects = [];

        if (!currentData?.trees) return;

        const themeColors = getThemeColors();
        const repos = Object.entries(currentData.trees).filter(([name]) => !hiddenRepos.has(name));
        const numRepos = repos.length;

        if (numRepos === 0) return;

        // Calculate grid layout for repos - arrange in a flat grid with large spacing
        const cols = Math.ceil(Math.sqrt(numRepos));
        const spacing = 25; // Larger spacing for radial PR layout

        repos.forEach(([repoName, tree], index) => {
            const col = index % cols;
            const row = Math.floor(index / cols);
            const x = (col - (cols - 1) / 2) * spacing;
            const z = (row - Math.floor(numRepos / cols) / 2) * spacing;

            buildRepoTree(tree, x, 0, z, repoName, themeColors);
        });
    }

    function buildRepoTree(tree, x, y, z, repoName, themeColors) {
        // Repo center sphere
        const repoGeom = new THREE.SphereGeometry(1.2, 32, 32);
        const repoMat = new THREE.MeshPhongMaterial({
            color: CONFIG.colors.default,
            emissive: CONFIG.colors.default,
            emissiveIntensity: 0.2,
        });
        const repoSphere = new THREE.Mesh(repoGeom, repoMat);
        repoSphere.position.set(x, y, z);
        repoSphere.userData = { isDataObject: true, type: 'repo', name: repoName, url: tree.github_url };
        scene.add(repoSphere);
        clickableObjects.push(repoSphere);
        hoverableObjects.push(repoSphere);

        // Repo label (below the repo)
        const repoLabel = createTextSprite(repoName, 0.8, '#ffffff');
        repoLabel.position.set(x, y - 2.5, z);
        repoLabel.userData = { isDataObject: true };
        scene.add(repoLabel);

        // Build PRs radially around the repo
        if (tree.children?.length > 0) {
            const numChildren = tree.children.length;
            const baseRadius = 5; // Distance from repo center

            tree.children.forEach((child, index) => {
                // Distribute PRs radially around the repo (full circle)
                const angle = (index / numChildren) * Math.PI * 2;

                const childX = x + Math.cos(angle) * baseRadius;
                const childZ = z + Math.sin(angle) * baseRadius;
                const childY = y + 1.5; // Slightly elevated

                buildPRNode(child, childX, childY, childZ, x, y, z, repoName, themeColors, 0, angle);
            });
        }
    }

    function buildPRNode(node, x, y, z, parentX, parentY, parentZ, repoName, themeColors, depth, angle = 0) {
        const color = getNodeColor(node);
        const radius = node.is_draft ? 0.35 : 0.5;

        const prGeom = new THREE.SphereGeometry(radius, 16, 16);
        const prMat = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 0.3,
            transparent: node.is_draft,
            opacity: node.is_draft ? 0.6 : 1.0,
        });
        const prSphere = new THREE.Mesh(prGeom, prMat);
        prSphere.position.set(x, y, z);
        prSphere.userData = {
            isDataObject: true,
            type: 'pr',
            name: node.name,
            repoName: repoName,
            prNumber: node.pr_number,
            prTitle: node.pr_title,
            prUrl: node.pr_url,
            prAuthor: node.pr_author,
            lastUpdated: node.last_updated,
            ciStatus: node.ci_status,
            labels: node.labels || [],
            isDraft: node.is_draft,
        };
        scene.add(prSphere);
        clickableObjects.push(prSphere);
        hoverableObjects.push(prSphere);

        // Connection line
        const lineGeom = new THREE.BufferGeometry();
        lineGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
            parentX, parentY, parentZ, x, y, z
        ]), 3));
        const lineMat = new THREE.LineBasicMaterial({ color: themeColors.lineColor, transparent: true, opacity: 0.6 });
        const line = new THREE.Line(lineGeom, lineMat);
        line.userData = { isDataObject: true };
        scene.add(line);

        // Commit points along the line - use avatars if available
        const commits = node.commits_from_parent || [];
        const maxCommits = Math.min(commits.length, 10);
        if (maxCommits > 0) {
            commits.slice(0, maxCommits).forEach((commit, i) => {
                // Position commits evenly along the line (excluding endpoints)
                const t = (i + 1) / (maxCommits + 1);
                const cx = parentX + (x - parentX) * t;
                const cy = parentY + (y - parentY) * t;
                const cz = parentZ + (z - parentZ) * t;

                let commitNode;
                const avatarUrl = commit.author_avatar_url;

                if (avatarUrl) {
                    // Use avatar sprite
                    commitNode = createAvatarSprite(avatarUrl);
                    commitNode.scale.set(0.5, 0.5, 0.5);
                } else {
                    // Fallback to colored sphere
                    const commitColor = isDarkMode ? 0x88aaff : 0x5577dd;
                    const commitGeom = new THREE.SphereGeometry(0.15, 8, 8);
                    const commitMat = new THREE.MeshPhongMaterial({
                        color: commitColor,
                        emissive: commitColor,
                        emissiveIntensity: 0.4,
                    });
                    commitNode = new THREE.Mesh(commitGeom, commitMat);
                }

                commitNode.position.set(cx, cy, cz);
                commitNode.userData = {
                    isDataObject: true,
                    type: 'commit',
                    sha: commit.sha,
                    shortSha: commit.short_sha,
                    message: commit.message,
                    author: commit.author,
                    authorLogin: commit.author_login,
                    date: commit.date,
                    url: commit.html_url,
                    hasAvatar: !!avatarUrl,
                };
                scene.add(commitNode);
                clickableObjects.push(commitNode);
                hoverableObjects.push(commitNode);
            });
        }

        // PR label
        const labelText = node.pr_number ? `#${node.pr_number}` : node.branch?.slice(0, 15);
        const ciIcon = getCIIcon(node.ci_status);
        const label = createTextSprite(`${labelText} ${ciIcon}`, 0.5, getLabelColor(node.ci_status));
        label.position.set(x, y + 1, z);
        label.userData = { isDataObject: true };
        scene.add(label);

        // Recursive children (stacked PRs) - continue outward radially
        if (node.children?.length > 0 && depth < 3) {
            const numChildren = node.children.length;
            const stackDistance = 3; // Distance for stacked PRs

            node.children.forEach((child, index) => {
                // Fan out children slightly if multiple, continuing in same radial direction
                const angleSpread = Math.PI * 0.3; // Spread angle for multiple children
                const childAngleOffset = numChildren > 1
                    ? (index / (numChildren - 1) - 0.5) * angleSpread
                    : 0;
                const childAngle = angle + childAngleOffset;

                const childX = x + Math.cos(childAngle) * stackDistance;
                const childZ = z + Math.sin(childAngle) * stackDistance;
                const childY = y + 1; // Slightly higher

                buildPRNode(child, childX, childY, childZ, x, y, z, repoName, themeColors, depth + 1, childAngle);
            });
        }
    }

    function getNodeColor(node) {
        if (node.ci_status === 'fail') return CONFIG.colors.fail;
        if (node.ci_status === 'pending') return CONFIG.colors.pending;
        if (node.ci_status === 'pass') return CONFIG.colors.pass;
        return CONFIG.colors.fresh;
    }

    function getCIIcon(status) {
        if (status === 'pass') return 'âœ“';
        if (status === 'fail') return 'âœ—';
        if (status === 'pending') return 'â‹¯';
        return 'â—Œ';
    }

    function getLabelColor(status) {
        if (status === 'pass') return '#22c55e';
        if (status === 'fail') return '#ef4444';
        if (status === 'pending') return '#eab308';
        return '#aaaaaa';
    }

    function createTextSprite(text, scale, color) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 128;

        ctx.fillStyle = color;
        ctx.font = 'bold 48px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 256, 64);

        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;

        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(scale * 4, scale, 1);

        return sprite;
    }

    // ============================================================================
    // Hide Menu
    // ============================================================================

    function buildHideMenu() {
        const reposList = document.getElementById('repos-list');
        reposList.innerHTML = '';

        if (!currentData?.trees) return;

        Object.keys(currentData.trees).sort().forEach(repoName => {
            const isHidden = hiddenRepos.has(repoName);
            const item = document.createElement('div');
            item.className = `menu-item ${isHidden ? 'hidden' : ''}`;
            item.innerHTML = `
                <span class="name">${repoName}</span>
                <span class="status-badge ${isHidden ? 'hidden' : 'visible'}">${isHidden ? 'Hidden' : 'Visible'}</span>
            `;
            item.onclick = () => toggleRepoVisibility(repoName);
            reposList.appendChild(item);
        });
    }

    function toggleRepoVisibility(repoName) {
        if (hiddenRepos.has(repoName)) {
            hiddenRepos.delete(repoName);
        } else {
            hiddenRepos.add(repoName);
        }
        buildHideMenu();
        if (!isLocked) buildScene();
    }

    function showAllRepos() {
        hiddenRepos.clear();
        buildHideMenu();
        if (!isLocked) buildScene();
    }

    function toggleHideMenu() {
        hideMenuOpen = !hideMenuOpen;
        document.getElementById('hide-menu').style.display = hideMenuOpen ? 'block' : 'none';
    }

    // ============================================================================
    // Camera Controls
    // ============================================================================

    function updateCameraPosition() {
        camera.position.x = cameraTargetX + Math.sin(cameraAngle) * cameraRadius;
        camera.position.y = cameraHeight;
        camera.position.z = cameraTargetZ + Math.cos(cameraAngle) * cameraRadius;
        camera.lookAt(cameraTargetX, 0, cameraTargetZ);
    }

    function onMouseDown(event) {
        if (event.shiftKey) isPanning = true;
        else isDragging = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function onMouseMove(event) {
        const deltaX = event.clientX - lastMouseX;
        const deltaY = event.clientY - lastMouseY;

        if (isDragging) {
            cameraAngle -= deltaX * 0.005;
            cameraHeight += deltaY * 0.1;
            cameraHeight = Math.max(5, Math.min(80, cameraHeight));
            updateCameraPosition();
        } else if (isPanning) {
            const panSpeed = 0.03 * cameraRadius;
            cameraTargetX -= deltaX * panSpeed * Math.cos(cameraAngle);
            cameraTargetZ += deltaX * panSpeed * Math.sin(cameraAngle);
            cameraTargetX -= deltaY * panSpeed * Math.sin(cameraAngle) * 0.5;
            cameraTargetZ -= deltaY * panSpeed * Math.cos(cameraAngle) * 0.5;
            updateCameraPosition();
        } else {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            checkHover(event);
        }

        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function onMouseUp() {
        isDragging = false;
        isPanning = false;
    }

    function onMouseWheel(event) {
        event.preventDefault();
        cameraRadius += event.deltaY * 0.05;
        cameraRadius = Math.max(10, Math.min(150, cameraRadius));
        updateCameraPosition();
    }

    function onClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableObjects);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            const url = obj.userData.prUrl || obj.userData.url || obj.userData.html_url;
            if (url) window.open(url, '_blank');
        }
    }

    function checkHover(event) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(hoverableObjects);
        const tooltip = document.getElementById('tooltip');

        if (intersects.length > 0) {
            const data = intersects[0].object.userData;

            if (data.type === 'commit') {
                // Commit tooltip
                tooltip.querySelector('.tooltip-title').textContent = data.shortSha;
                tooltip.querySelector('.tooltip-repo').textContent = data.message || '';
                tooltip.querySelector('.tooltip-author').textContent = data.author ? `by ${data.author}` : '';
                tooltip.querySelector('.tooltip-time').textContent = data.date || '';
                tooltip.querySelector('.tooltip-labels').innerHTML = '';
            } else {
                // PR or repo tooltip
                tooltip.querySelector('.tooltip-title').textContent = data.prTitle || data.name || 'Unknown';
                tooltip.querySelector('.tooltip-repo').textContent = data.repoName || '';
                tooltip.querySelector('.tooltip-author').textContent = data.prAuthor ? `by @${data.prAuthor}` : '';

                if (data.lastUpdated) {
                    const date = new Date(data.lastUpdated);
                    tooltip.querySelector('.tooltip-time').textContent = `Updated ${getTimeAgo(date)}`;
                } else {
                    tooltip.querySelector('.tooltip-time').textContent = '';
                }

                const labelsContainer = tooltip.querySelector('.tooltip-labels');
                labelsContainer.innerHTML = '';
                (data.labels || []).forEach(label => {
                    const tag = document.createElement('span');
                    tag.className = 'label-tag';
                    tag.textContent = label;
                    labelsContainer.appendChild(tag);
                });
            }

            tooltip.style.display = 'block';
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
        } else {
            tooltip.style.display = 'none';
        }
    }

    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 60) return 'just now';
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
        if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
        if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
        return date.toLocaleDateString();
    }

    // ============================================================================
    // UI Controls
    // ============================================================================

    function toggleTheme() {
        isDarkMode = !isDarkMode;
        document.body.classList.toggle('light-mode', !isDarkMode);
        document.getElementById('theme-icon').textContent = isDarkMode ? 'â˜¾' : 'â˜€';
        document.getElementById('theme-label').textContent = isDarkMode ? 'Light' : 'Dark';

        const themeColors = getThemeColors();
        scene.background = new THREE.Color(themeColors.background);
        scene.fog.color = new THREE.Color(themeColors.background);

        // Update grid
        const oldGrid = scene.getObjectByName('gridHelper');
        if (oldGrid) {
            scene.remove(oldGrid);
            oldGrid.geometry.dispose();
            oldGrid.material.dispose();
            const newGrid = new THREE.GridHelper(100, 50, themeColors.gridColor, themeColors.gridColor);
            newGrid.position.y = -3;
            newGrid.name = 'gridHelper';
            scene.add(newGrid);
        }

        buildScene();
    }

    function toggleLock() {
        isLocked = !isLocked;
        const btn = document.getElementById('lock-button');
        btn.classList.toggle('active', isLocked);
        document.getElementById('lock-icon').textContent = isLocked ? 'ðŸ”’' : 'ðŸ”“';
        document.getElementById('lock-label').textContent = isLocked ? 'Locked' : 'Lock';
    }

    function fitToScreen() {
        if (!currentData?.trees) return;
        const numRepos = Object.keys(currentData.trees).filter(n => !hiddenRepos.has(n)).length;
        if (numRepos === 0) return;

        const cols = Math.ceil(Math.sqrt(numRepos));
        const extent = cols * 12 / 2 + 10;

        cameraRadius = extent * 2;
        cameraHeight = extent * 0.8;
        cameraTargetX = 0;
        cameraTargetZ = 0;
        updateCameraPosition();
    }

    // ============================================================================
    // Render Loop
    // ============================================================================

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }

    // Start
    init();
    </script>
</body>
</html>
